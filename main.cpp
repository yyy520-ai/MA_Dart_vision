#include <QApplication>
#include <QThread>
#include <QDebug>
#include <QTimer>
#include <atomic>
#include <opencv2/opencv.hpp>
#include "threadpool/ThreadPool.hpp"
#include "lockfree/LockFree.hpp"
#include "hikrobot/HikRobot.hpp"

#include "Detect.hpp"
#include "Track.hpp"
#include "Mouse.hpp"

#include "function/function.hpp"
#include "LatestFrame.hpp"
#ifndef MCAP_IMPLEMENTATION
#define MCAP_IMPLEMENTATION
#endif
#include "Capture.hpp"

#//#define DUMP
#ifndef DUMP
#if 0 // disable CAPTURE/MCAP writing by default
#define CAPTURE
#endif
#else
#include "dump/dump.hpp"
#endif


int main(int argc, char *argv[]) {
    QApplication app(argc, argv); // 主线程创建 Qt 核心对象
    cv::namedWindow("img", cv::WINDOW_NORMAL);
    cv::namedWindow("detect", cv::WINDOW_NORMAL);
    cv::namedWindow("track", cv::WINDOW_NORMAL);
    cv::moveWindow("track", 100, 100);
    cv::startWindowThread();

    ThreadPool t_p;
    LfStack<FromData> fd_msgs;
    LfStack<cv::Mat> display_stack;
    std::atomic<bool> running{true};
#ifndef DUMP
    LfStack<ImageInfo> image_info_stack;
    LfStack<ImageInfo> mouse_info_stack;
    SerialPort sp;

    bool capture_enabled = false;
    if (!J_CAPTURE.config_["enabled"].empty()) {
        J_CAPTURE.config_["enabled"] >> capture_enabled;
    }

    LfStack<CaptureInfo> capture_stack;

    auto receive = [&]() -> void {
        HikRobot hik(sp);
        hik.cameraInit();
        while (running.load()) {
            hik.refreshImage(fd_msgs, display_stack);   
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    };

    auto detect = [&]() -> void {
        Detect detect("debug");
        while (running.load()) {
            detect.detect(fd_msgs, image_info_stack, mouse_info_stack);
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    };


    auto track = [&]() -> void {
        Track tracker(sp, "debug");
        while (running.load()) {
            if (capture_enabled) {
                tracker.update(image_info_stack, capture_stack);
            } else {
                tracker.update(image_info_stack);
            }
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    };


    auto mouse = [&]() -> void {
        Mouse m;
        while (running.load()) {
            m.mouseControl(mouse_info_stack);
            std::this_thread::sleep_for(std::chrono::milliseconds(1));
        }
    };

    std::optional<std::function<void()>> capture_func_opt;
    if (capture_enabled) {
        capture_func_opt = [&]() -> void {
            std::cout << "capture thread start." << std::endl;
            Capture cap("/Dart",
                        "Vision",
                        "foxglove.CaptureInformation",
                        "../config/autogenerated_flatbuffers/CaptureInformation.bfbs",
                        "8UC3");
            cap.setMacpPath(function::getBagPath());
            cap.init();
            int frame_count = 0;
            if (J_CAPTURE.config_["frame_cnt"].empty()) {
                qCritical() << "Invalid frame_cnt config, set default 1000";
                frame_count = 1000;
            } else {
                J_CAPTURE.config_["frame_cnt"] >> frame_count;
                if (frame_count <= 0) {
                    qCritical() << "Invalid frame_cnt value, set default 1000";
                    frame_count = 1000;
                }
            }
            while(true) {
                if (QThread::currentThread()->isInterruptionRequested()) {
                    cap.finish();
                    break;
                }
                std::optional<CaptureInfo> opt_value = capture_stack.pop();
                if (!opt_value.has_value() || opt_value.value().cd.dune == 1 || !opt_value.value().cd.mode) {
                    QThread::msleep(1);
                    continue;
                }
                cap.update(opt_value.value());
                if (!(--frame_count)) {
                    cap.finish();
                    cap.setMacpPath(function::getBagPath());
                    cap.init();
                    J_CAPTURE.config_["frame_cnt"] >> frame_count;
                    if (frame_count <= 0) frame_count = 1000;
                }
            }
        };
    }

    t_p.addTask(receive);
    t_p.addTask(detect);
    t_p.addTask(track);
    t_p.addTask(mouse);
    if (capture_func_opt.has_value()) {
        t_p.addTask(capture_func_opt.value());
    }
#else
    auto dump = [&]() -> void {
        std::string directory;
        std::string name;
        std::string type;
        J_CAPTURE.config_["mcap"]["directory"] >> directory;
        J_CAPTURE.config_["mcap"]["name"] >> name;
        J_CAPTURE.config_["mcap"]["type"] >> type;
        std::cout << directory + name + type << std::endl;
        std::ifstream input(directory + name + type, std::ios::binary);
        mcap::FileStreamReader dataSource{input};
        DumpMessages(name, dataSource, fd_msgs);
    };
    t_p.addTask(dump);
#endif
    // stop workers when Qt is exiting
    QObject::connect(&app, &QCoreApplication::aboutToQuit, [&]() {
        running.store(false);
    });

    // Main-thread display timer: pop latest frame and show it
    QTimer *displayTimer = new QTimer();
    QObject::connect(displayTimer, &QTimer::timeout, [&]() {
        // try global latest_frame first
    std::shared_ptr<cv::Mat> mptr = std::atomic_load_explicit(&::latest_frame, std::memory_order_acquire);
        if (mptr && !mptr->empty()) {
            static int display_count = 0;
            cv::Mat m = *mptr;
            ::frames_displayed.fetch_add(1, std::memory_order_relaxed);
            if ((display_count++ % 30) == 0) {
                cv::Mat gray;
                cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY);
                double minv, maxv;
                cv::minMaxLoc(gray, &minv, &maxv);
                std::cout << "display(latest): frame size=" << m.cols << "x" << m.rows << " min=" << minv << " max=" << maxv << std::endl;
            }
            cv::imshow("img", m);
            cv::waitKey(1);
            return;
        }

        std::optional<cv::Mat> opt = display_stack.pop();
        if (opt.has_value()) {
            static int display_count2 = 0;
            cv::Mat m = opt.value();
            ::frames_displayed.fetch_add(1, std::memory_order_relaxed);
            if ((display_count2++ % 30) == 0) {
                cv::Mat gray;
                cv::cvtColor(m, gray, cv::COLOR_BGR2GRAY);
                double minv, maxv;
                cv::minMaxLoc(gray, &minv, &maxv);
                std::cout << "display: frame size=" << m.cols << "x" << m.rows << " min=" << minv << " max=" << maxv << std::endl;
            }
            cv::imshow("img", m);
            cv::waitKey(1);
        } else {
            static int empty_count = 0;
            if ((++empty_count % 30) == 0) {
                std::cout << "display: no frame in display_stack" << std::endl;
            }
        }
    });
    displayTimer->start(30); // ~33 FPS refresh on GUI thread

    QTimer *fpsTimer = new QTimer();
    QObject::connect(fpsTimer, &QTimer::timeout, [&]() {
        uint32_t p = ::frames_produced.exchange(0, std::memory_order_relaxed);
        uint32_t d = ::frames_displayed.exchange(0, std::memory_order_relaxed);
        std::cout << "FPS_STAT: produced=" << p/2.0 << " fps, displayed=" << d/2.0 << " fps (per-second average)" << std::endl;
    });
    fpsTimer->start(2000);

    return app.exec(); // Qt 主线程事件循环
}
