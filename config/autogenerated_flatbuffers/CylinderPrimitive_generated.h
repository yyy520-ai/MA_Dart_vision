// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CYLINDERPRIMITIVE_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_CYLINDERPRIMITIVE_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "Color_generated.h"
#include "Pose_generated.h"
#include "Vector3_generated.h"

namespace foxglove {

struct CylinderPrimitive;
struct CylinderPrimitiveBuilder;

/// A primitive representing a cylinder, elliptic cylinder, or truncated cone
struct CylinderPrimitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CylinderPrimitiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSE = 4,
    VT_SIZE = 6,
    VT_BOTTOM_SCALE = 8,
    VT_TOP_SCALE = 10,
    VT_COLOR = 12
  };
  /// Position of the center of the cylinder and orientation of the cylinder. The flat face(s) are perpendicular to the z-axis.
  const foxglove::Pose *pose() const {
    return GetPointer<const foxglove::Pose *>(VT_POSE);
  }
  /// Size of the cylinder's bounding box
  const foxglove::Vector3 *size() const {
    return GetPointer<const foxglove::Vector3 *>(VT_SIZE);
  }
  /// 0-1, ratio of the diameter of the cylinder's bottom face (min z) to the bottom of the bounding box
  double bottom_scale() const {
    return GetField<double>(VT_BOTTOM_SCALE, 0.0);
  }
  /// 0-1, ratio of the diameter of the cylinder's top face (max z) to the top of the bounding box
  double top_scale() const {
    return GetField<double>(VT_TOP_SCALE, 0.0);
  }
  /// Color of the cylinder
  const foxglove::Color *color() const {
    return GetPointer<const foxglove::Color *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POSE) &&
           verifier.VerifyTable(pose()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyTable(size()) &&
           VerifyField<double>(verifier, VT_BOTTOM_SCALE, 8) &&
           VerifyField<double>(verifier, VT_TOP_SCALE, 8) &&
           VerifyOffset(verifier, VT_COLOR) &&
           verifier.VerifyTable(color()) &&
           verifier.EndTable();
  }
};

struct CylinderPrimitiveBuilder {
  typedef CylinderPrimitive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pose(flatbuffers::Offset<foxglove::Pose> pose) {
    fbb_.AddOffset(CylinderPrimitive::VT_POSE, pose);
  }
  void add_size(flatbuffers::Offset<foxglove::Vector3> size) {
    fbb_.AddOffset(CylinderPrimitive::VT_SIZE, size);
  }
  void add_bottom_scale(double bottom_scale) {
    fbb_.AddElement<double>(CylinderPrimitive::VT_BOTTOM_SCALE, bottom_scale, 0.0);
  }
  void add_top_scale(double top_scale) {
    fbb_.AddElement<double>(CylinderPrimitive::VT_TOP_SCALE, top_scale, 0.0);
  }
  void add_color(flatbuffers::Offset<foxglove::Color> color) {
    fbb_.AddOffset(CylinderPrimitive::VT_COLOR, color);
  }
  explicit CylinderPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CylinderPrimitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CylinderPrimitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<CylinderPrimitive> CreateCylinderPrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<foxglove::Pose> pose = 0,
    flatbuffers::Offset<foxglove::Vector3> size = 0,
    double bottom_scale = 0.0,
    double top_scale = 0.0,
    flatbuffers::Offset<foxglove::Color> color = 0) {
  CylinderPrimitiveBuilder builder_(_fbb);
  builder_.add_top_scale(top_scale);
  builder_.add_bottom_scale(bottom_scale);
  builder_.add_color(color);
  builder_.add_size(size);
  builder_.add_pose(pose);
  return builder_.Finish();
}

inline const foxglove::CylinderPrimitive *GetCylinderPrimitive(const void *buf) {
  return flatbuffers::GetRoot<foxglove::CylinderPrimitive>(buf);
}

inline const foxglove::CylinderPrimitive *GetSizePrefixedCylinderPrimitive(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<foxglove::CylinderPrimitive>(buf);
}

inline bool VerifyCylinderPrimitiveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::CylinderPrimitive>(nullptr);
}

inline bool VerifySizePrefixedCylinderPrimitiveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::CylinderPrimitive>(nullptr);
}

inline void FinishCylinderPrimitiveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::CylinderPrimitive> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCylinderPrimitiveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::CylinderPrimitive> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_CYLINDERPRIMITIVE_FOXGLOVE_H_
