// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAMERACALIBRATION_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_CAMERACALIBRATION_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "Time_generated.h"

namespace foxglove {

struct CameraCalibration;
struct CameraCalibrationBuilder;

/// Camera calibration parameters
struct CameraCalibration FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CameraCalibrationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIMESTAMP = 4,
    VT_FRAME_ID = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10,
    VT_DISTORTION_MODEL = 12,
    VT_D = 14,
    VT_K = 16,
    VT_R = 18,
    VT_P = 20
  };
  /// Timestamp of calibration data
  const foxglove::Time *timestamp() const {
    return GetStruct<const foxglove::Time *>(VT_TIMESTAMP);
  }
  /// Frame of reference for the camera. The origin of the frame is the optical center of the camera. +x points to the right in the image, +y points down, and +z points into the plane of the image.
  const flatbuffers::String *frame_id() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAME_ID);
  }
  /// Image width
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  /// Image height
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  /// Name of distortion model
  /// 
  /// Supported values: `plumb_bob` and `rational_polynomial`
  const flatbuffers::String *distortion_model() const {
    return GetPointer<const flatbuffers::String *>(VT_DISTORTION_MODEL);
  }
  /// Distortion parameters
  const flatbuffers::Vector<double> *d() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_D);
  }
  /// Intrinsic camera matrix (3x3 row-major matrix)
  /// 
  /// A 3x3 row-major matrix for the raw (distorted) image.
  /// 
  /// Projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx, fy) and principal point (cx, cy).
  /// 
  /// ```
  ///     [fx  0 cx]
  /// K = [ 0 fy cy]
  ///     [ 0  0  1]
  /// ```
  /// length 9
  const flatbuffers::Vector<double> *k() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_K);
  }
  /// Rectification matrix (stereo cameras only, 3x3 row-major matrix)
  /// 
  /// A rotation matrix aligning the camera coordinate system to the ideal stereo image plane so that epipolar lines in both stereo images are parallel.
  /// length 9
  const flatbuffers::Vector<double> *r() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_R);
  }
  /// Projection/camera matrix (3x4 row-major matrix)
  /// 
  /// ```
  ///     [fx'  0  cx' Tx]
  /// P = [ 0  fy' cy' Ty]
  ///     [ 0   0   1   0]
  /// ```
  /// 
  /// By convention, this matrix specifies the intrinsic (camera) matrix of the processed (rectified) image. That is, the left 3x3 portion is the normal camera intrinsic matrix for the rectified image.
  /// 
  /// It projects 3D points in the camera coordinate frame to 2D pixel coordinates using the focal lengths (fx', fy') and principal point (cx', cy') - these may differ from the values in K.
  /// 
  /// For monocular cameras, Tx = Ty = 0. Normally, monocular cameras will also have R = the identity and P[1:3,1:3] = K.
  /// 
  /// For a stereo pair, the fourth column [Tx Ty 0]' is related to the position of the optical center of the second camera in the first camera's frame. We assume Tz = 0 so both cameras are in the same stereo image plane. The first camera always has Tx = Ty = 0. For the right (second) camera of a horizontal stereo pair, Ty = 0 and Tx = -fx' * B, where B is the baseline between the cameras.
  /// 
  /// Given a 3D point [X Y Z]', the projection (x, y) of the point onto the rectified image is given by:
  /// 
  /// ```
  /// [u v w]' = P * [X Y Z 1]'
  ///        x = u / w
  ///        y = v / w
  /// ```
  /// 
  /// This holds for both images of a stereo pair.
  /// length 12
  const flatbuffers::Vector<double> *p() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_P);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<foxglove::Time>(verifier, VT_TIMESTAMP, 4) &&
           VerifyOffset(verifier, VT_FRAME_ID) &&
           verifier.VerifyString(frame_id()) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyOffset(verifier, VT_DISTORTION_MODEL) &&
           verifier.VerifyString(distortion_model()) &&
           VerifyOffset(verifier, VT_D) &&
           verifier.VerifyVector(d()) &&
           VerifyOffset(verifier, VT_K) &&
           verifier.VerifyVector(k()) &&
           VerifyOffset(verifier, VT_R) &&
           verifier.VerifyVector(r()) &&
           VerifyOffset(verifier, VT_P) &&
           verifier.VerifyVector(p()) &&
           verifier.EndTable();
  }
};

struct CameraCalibrationBuilder {
  typedef CameraCalibration Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_timestamp(const foxglove::Time *timestamp) {
    fbb_.AddStruct(CameraCalibration::VT_TIMESTAMP, timestamp);
  }
  void add_frame_id(flatbuffers::Offset<flatbuffers::String> frame_id) {
    fbb_.AddOffset(CameraCalibration::VT_FRAME_ID, frame_id);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(CameraCalibration::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(CameraCalibration::VT_HEIGHT, height, 0);
  }
  void add_distortion_model(flatbuffers::Offset<flatbuffers::String> distortion_model) {
    fbb_.AddOffset(CameraCalibration::VT_DISTORTION_MODEL, distortion_model);
  }
  void add_d(flatbuffers::Offset<flatbuffers::Vector<double>> d) {
    fbb_.AddOffset(CameraCalibration::VT_D, d);
  }
  void add_k(flatbuffers::Offset<flatbuffers::Vector<double>> k) {
    fbb_.AddOffset(CameraCalibration::VT_K, k);
  }
  void add_r(flatbuffers::Offset<flatbuffers::Vector<double>> r) {
    fbb_.AddOffset(CameraCalibration::VT_R, r);
  }
  void add_p(flatbuffers::Offset<flatbuffers::Vector<double>> p) {
    fbb_.AddOffset(CameraCalibration::VT_P, p);
  }
  explicit CameraCalibrationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CameraCalibration> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CameraCalibration>(end);
    return o;
  }
};

inline flatbuffers::Offset<CameraCalibration> CreateCameraCalibration(
    flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    flatbuffers::Offset<flatbuffers::String> frame_id = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    flatbuffers::Offset<flatbuffers::String> distortion_model = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> d = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> k = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> r = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> p = 0) {
  CameraCalibrationBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_r(r);
  builder_.add_k(k);
  builder_.add_d(d);
  builder_.add_distortion_model(distortion_model);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_frame_id(frame_id);
  builder_.add_timestamp(timestamp);
  return builder_.Finish();
}

inline flatbuffers::Offset<CameraCalibration> CreateCameraCalibrationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const foxglove::Time *timestamp = nullptr,
    const char *frame_id = nullptr,
    uint32_t width = 0,
    uint32_t height = 0,
    const char *distortion_model = nullptr,
    const std::vector<double> *d = nullptr,
    const std::vector<double> *k = nullptr,
    const std::vector<double> *r = nullptr,
    const std::vector<double> *p = nullptr) {
  auto frame_id__ = frame_id ? _fbb.CreateString(frame_id) : 0;
  auto distortion_model__ = distortion_model ? _fbb.CreateString(distortion_model) : 0;
  auto d__ = d ? _fbb.CreateVector<double>(*d) : 0;
  auto k__ = k ? _fbb.CreateVector<double>(*k) : 0;
  auto r__ = r ? _fbb.CreateVector<double>(*r) : 0;
  auto p__ = p ? _fbb.CreateVector<double>(*p) : 0;
  return foxglove::CreateCameraCalibration(
      _fbb,
      timestamp,
      frame_id__,
      width,
      height,
      distortion_model__,
      d__,
      k__,
      r__,
      p__);
}

inline const foxglove::CameraCalibration *GetCameraCalibration(const void *buf) {
  return flatbuffers::GetRoot<foxglove::CameraCalibration>(buf);
}

inline const foxglove::CameraCalibration *GetSizePrefixedCameraCalibration(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<foxglove::CameraCalibration>(buf);
}

inline bool VerifyCameraCalibrationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::CameraCalibration>(nullptr);
}

inline bool VerifySizePrefixedCameraCalibrationBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::CameraCalibration>(nullptr);
}

inline void FinishCameraCalibrationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::CameraCalibration> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCameraCalibrationBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::CameraCalibration> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_CAMERACALIBRATION_FOXGLOVE_H_
