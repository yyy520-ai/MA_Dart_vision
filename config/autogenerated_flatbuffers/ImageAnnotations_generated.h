// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_IMAGEANNOTATIONS_FOXGLOVE_H_
#define FLATBUFFERS_GENERATED_IMAGEANNOTATIONS_FOXGLOVE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "CircleAnnotation_generated.h"
#include "PointsAnnotation_generated.h"
#include "TextAnnotation_generated.h"

namespace foxglove {

struct ImageAnnotations;
struct ImageAnnotationsBuilder;

/// Array of annotations for a 2D image
struct ImageAnnotations FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageAnnotationsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CIRCLES = 4,
    VT_POINTS = 6,
    VT_TEXTS = 8
  };
  /// Circle annotations
  const flatbuffers::Vector<flatbuffers::Offset<foxglove::CircleAnnotation>> *circles() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<foxglove::CircleAnnotation>> *>(VT_CIRCLES);
  }
  /// Points annotations
  const flatbuffers::Vector<flatbuffers::Offset<foxglove::PointsAnnotation>> *points() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<foxglove::PointsAnnotation>> *>(VT_POINTS);
  }
  /// Text annotations
  const flatbuffers::Vector<flatbuffers::Offset<foxglove::TextAnnotation>> *texts() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<foxglove::TextAnnotation>> *>(VT_TEXTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CIRCLES) &&
           verifier.VerifyVector(circles()) &&
           verifier.VerifyVectorOfTables(circles()) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.VerifyVectorOfTables(points()) &&
           VerifyOffset(verifier, VT_TEXTS) &&
           verifier.VerifyVector(texts()) &&
           verifier.VerifyVectorOfTables(texts()) &&
           verifier.EndTable();
  }
};

struct ImageAnnotationsBuilder {
  typedef ImageAnnotations Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_circles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::CircleAnnotation>>> circles) {
    fbb_.AddOffset(ImageAnnotations::VT_CIRCLES, circles);
  }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::PointsAnnotation>>> points) {
    fbb_.AddOffset(ImageAnnotations::VT_POINTS, points);
  }
  void add_texts(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::TextAnnotation>>> texts) {
    fbb_.AddOffset(ImageAnnotations::VT_TEXTS, texts);
  }
  explicit ImageAnnotationsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ImageAnnotations> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageAnnotations>(end);
    return o;
  }
};

inline flatbuffers::Offset<ImageAnnotations> CreateImageAnnotations(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::CircleAnnotation>>> circles = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::PointsAnnotation>>> points = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<foxglove::TextAnnotation>>> texts = 0) {
  ImageAnnotationsBuilder builder_(_fbb);
  builder_.add_texts(texts);
  builder_.add_points(points);
  builder_.add_circles(circles);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageAnnotations> CreateImageAnnotationsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<foxglove::CircleAnnotation>> *circles = nullptr,
    const std::vector<flatbuffers::Offset<foxglove::PointsAnnotation>> *points = nullptr,
    const std::vector<flatbuffers::Offset<foxglove::TextAnnotation>> *texts = nullptr) {
  auto circles__ = circles ? _fbb.CreateVector<flatbuffers::Offset<foxglove::CircleAnnotation>>(*circles) : 0;
  auto points__ = points ? _fbb.CreateVector<flatbuffers::Offset<foxglove::PointsAnnotation>>(*points) : 0;
  auto texts__ = texts ? _fbb.CreateVector<flatbuffers::Offset<foxglove::TextAnnotation>>(*texts) : 0;
  return foxglove::CreateImageAnnotations(
      _fbb,
      circles__,
      points__,
      texts__);
}

inline const foxglove::ImageAnnotations *GetImageAnnotations(const void *buf) {
  return flatbuffers::GetRoot<foxglove::ImageAnnotations>(buf);
}

inline const foxglove::ImageAnnotations *GetSizePrefixedImageAnnotations(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<foxglove::ImageAnnotations>(buf);
}

inline bool VerifyImageAnnotationsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<foxglove::ImageAnnotations>(nullptr);
}

inline bool VerifySizePrefixedImageAnnotationsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<foxglove::ImageAnnotations>(nullptr);
}

inline void FinishImageAnnotationsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::ImageAnnotations> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedImageAnnotationsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<foxglove::ImageAnnotations> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace foxglove

#endif  // FLATBUFFERS_GENERATED_IMAGEANNOTATIONS_FOXGLOVE_H_
